import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:path_provider/path_provider.dart';

import '../../domain/entities/template.dart';

/// Provider for PDF generation and management
class PDFProvider extends ChangeNotifier {
  bool _isGenerating = false;
  String? _error;
  File? _lastGeneratedPdf;

  /// Whether PDF generation is in progress
  bool get isGenerating => _isGenerating;
  
  /// Last error message
  String? get error => _error;
  
  /// Last generated PDF file
  File? get lastGeneratedPdf => _lastGeneratedPdf;

  /// Generate PDF from template and user data
  Future<File?> generatePdf({
    required Template template,
    required Map<String, dynamic> userData,
    String? fileName,
  }) async {
    _isGenerating = true;
    _error = null;
    notifyListeners();

    try {
      final pdf = pw.Document();
      
      // Create PDF content based on template
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return _buildPdfContent(template, userData);
          },
        ),
      );

      // Save PDF to file
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/${fileName ?? 'document_${DateTime.now().millisecondsSinceEpoch}'}.pdf');
      
      await file.writeAsBytes(await pdf.save());
      
      _lastGeneratedPdf = file;
      
      if (kDebugMode) {
        print('PDF generated successfully: ${file.path}');
      }
      
      return file;
    } catch (e) {
      _error = e.toString();
      if (kDebugMode) {
        print('PDF generation error: $e');
      }
      return null;
    } finally {
      _isGenerating = false;
      notifyListeners();
    }
  }

  /// Build PDF content from template and user data
  pw.Widget _buildPdfContent(Template template, Map<String, dynamic> userData) {
    String processedBody = template.body;
    
    // Replace placeholders with user data
    template.placeholders.forEach((key, config) {
      final value = userData[key]?.toString() ?? '';
      processedBody = processedBody.replaceAll('{{$key}}', value);
    });

    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        // Title
        pw.Text(
          template.title,
          style: pw.TextStyle(
            fontSize: 24,
            fontWeight: pw.FontWeight.bold,
          ),
        ),
        pw.SizedBox(height: 20),
        
        // Content
        pw.Text(
          processedBody,
          style: const pw.TextStyle(fontSize: 12),
        ),
        
        pw.Spacer(),
        
        // Footer
        pw.Text(
          'Generated by QuickPDF - ${DateTime.now().toString()}',
          style: const pw.TextStyle(
            fontSize: 8,
            color: PdfColors.grey,
          ),
        ),
      ],
    );
  }

  /// Preview PDF
  Future<void> previewPdf({
    required Template template,
    required Map<String, dynamic> userData,
  }) async {
    try {
      final pdf = pw.Document();
      
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return _buildPdfContent(template, userData);
          },
        ),
      );

      await Printing.layoutPdf(
        onLayout: (PdfPageFormat format) async => pdf.save(),
      );
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      if (kDebugMode) {
        print('PDF preview error: $e');
      }
    }
  }

  /// Share PDF
  Future<void> sharePdf(File pdfFile) async {
    try {
      await Printing.sharePdf(
        bytes: await pdfFile.readAsBytes(),
        filename: pdfFile.path.split('/').last,
      );
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      if (kDebugMode) {
        print('PDF share error: $e');
      }
    }
  }

  /// Clear error
  void clearError() {
    _error = null;
    notifyListeners();
  }

  /// Get PDF file size in MB
  Future<double> getPdfSize(File pdfFile) async {
    try {
      final bytes = await pdfFile.length();
      return bytes / (1024 * 1024); // Convert to MB
    } catch (e) {
      return 0.0;
    }
  }

  /// Delete PDF file
  Future<bool> deletePdf(File pdfFile) async {
    try {
      if (await pdfFile.exists()) {
        await pdfFile.delete();
        if (_lastGeneratedPdf?.path == pdfFile.path) {
          _lastGeneratedPdf = null;
          notifyListeners();
        }
        return true;
      }
      return false;
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Get last generated PDF file
  File? get lastGeneratedPDF => _lastGeneratedPdf;

  /// Check if offline mode is enabled
  bool get isOfflineMode => false; // Simplified for now

  /// Set offline mode
  void setOfflineMode(bool enabled) {
    // Implementation for offline mode
    notifyListeners();
  }

  /// Set generating state
  void setGenerating(bool generating) {
    _isGenerating = generating;
    notifyListeners();
  }

  /// Set error message
  void setError(String? error) {
    _error = error;
    notifyListeners();
  }
}